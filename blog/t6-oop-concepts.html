<!DOCTYPE html>
<head>
  <!-- Insert page title & ensure it matches post title -->
  <title id="title">Inheritance and Composition</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet-keyboard.css">
</head>

<header>
  <a href="../index.html">
    <figure>
      <img id="jq-key" class="top-keys" src="../assets/keys/JQ.png">
      <figcaption>Home</figcaption>
    </figure>
  </a>
  <a href="allposts.html">
    <figure>
      <img id="b-key" class="top-keys" src="../assets/keys/B_key.png">
      <figcaption>All Posts</figcaption>
    </figure>
  </a>
</header>

<main>
  <!-- Insert title below -->
  <h1 id="post_title">(This gets replaced through JS magick)</h1>
  <!-- Subtitle, if you want it -->
  <!-- <h3>Subtitle</h3> -->
  <!-- Date -->
  <h4>2014.6.7</h4>

  <section>
    <p>
      Organizing classes with Ruby can be a tough design task. Here I want to provide a very simple overview of two ways to organize classes in Ruby: inheritance and composition.
    </p>
    <p>
      Some of the best overviews are helpful, but also kind of dry (e.g., <a href="http://learnrubythehardway.org/book/ex44.html">Shaw</a> and <a href="http://www.poodr.com/">Metz Ch. 8</a>). Here I just want to go over a few very mundane examples.
    </p>
    <p>
      Let's start with a very basic <code>Dog</code> class. Perhaps all that will be unfamiliar to the novice (at least by week 6 of Dev Bootcamp) in what follows is <code>include</code>, which I will explain soon:
    </p>

    <pre><code>
      require './care_for_module'

      class Dog
        include CareFor
        attr_reader :name, :breed
        attr_accessor :age, :length, :height, :weight

        def initialize(name, breed="", age=1, length=90, height=30, weight=9)
          @name = name.capitalize
          @breed = breed.split('').each {|ele| ele.capitalize}.join('')
          @age = age
          @length = length
          @height = height
          @weight = weight
        end

        def inspect
          "A #{@breed} dog named #{@name} aged #{@age} years, measuring #{@length} by #{@height} cm and weighing #{@weight} kg."
        end

        @@calls_by_breed = {"Collie" => "Woof!", "Dachshund" => "Arf!", "Husky" => "Raouf!", "Rottweiler" => "Grrr...", "Saint Bernard" => "Bow Wow!"}
        def speak
          "#{@name} says #{@@calls_by_breed[@breed]}!"
        end

      end
    </code></pre>

    <h3>Inheritance</h3>
    <p>
      With inheritance, child classes inherit the methods from their parents. In Ruby, the way to make this happen is simply by writing in the <code><</code> symbol followed by the name of the parent class. For example:
    </p>
    <pre><code>
      require './dog.rb'

      class FrisbeeTerrier < Dog

      attr_accessor :vertical, :frisbees_can_catch

        def vertical
          "#{name} can jump #{@vertical} feet in the air!"
        end

        def frisbees_can_catch=(num)
          @frisbees_can_catch = num
          puts "#{name} trains to catch #{num} frisbees at once!"
        end

        def catch_frisbees
          "#{name} jumped #{vertical} feet in the air and caught #{rand(@frisbees_can_catch)} frisbees!"
        end

      end

      p bandit = FrisbeeTerrier.new("Bandit","Collie")
      # => A Collie dog named Bandit aged 1 years, measuring 90 by 30 cm and weighing 9 kg.

      p bandit.speak  # => "Bandit says Woof!!"
    </code></pre>
    <p>The two methods invoked here, <code>inspect</code> and <code>speak</code> are simply inherited from the parent class, <code>Dog</code>.</p>
    <p>The point of creating the child class was that we wanted to be able to add additinal functionality. That's precisely what the new methods of <code>FrisbeeTerrier</code> do for us:</p>
    <pre><code>
      bandit.vertical = 7
      p bandit.vertical # => "Bandit can jump 7 feet in the air!"
      bandit.frisbees_can_catch = 5 # => Bandit trains to catch 5 frisbees at once!
      p bandit.catch_frisbees # => "Bandit jumped Bandit can jump 7 feet in the air! feet in the air and caught 1 frisbees!"
    </code></pre>
    <p>Bah, Bandit just got unlucky this time.</p>

    <h3>Composition: Objects in Objects</h3>
    <p>
      Sometimes we want to be able to marshal the functionality of another class without wanting to inherit every behavior. For example, if we want to make a <code>DogSledTeam</code> class, we'd want some <code>Dog</code>s to exist inside it, although we wouldn't want the <code>DogSledTeam</code> class <em>itself</em> to inherit behaviors like, e.g., <code>speak</code>.
    </p>
    <p>
      To that end, we can simply build methods inside a class that create new objects (whether in the <code>initialize</code> step or elsewhere). For example, let's create a <code>DogSledTeam</code> class composed of <code>Dog</code>s and a <code>Sled</code> (and first let's make the sled class quickly):
    </p>
    <pre><code>
      require './dog.rb'
      require './care_for_module.rb'

      class Sled

        attr_accessor :speed, :color

        def initialize(speed=50,color="red")
          @speed = speed
          @color = color
        end

        def inspect
          "a #{color} sled capable of going #{speed} miles per hour."
        end

      end

      class DogSledTeam

        attr_reader :the_dogs

        def initialize
          @dog1 = Dog.new(name_husky, "Husky")
          @dog2 = Dog.new(name_husky, "Husky")
          @dog3 = Dog.new(name_husky, "Husky")
          @dog4 = Dog.new(name_husky, "Husky")
          @dog5 = Dog.new(name_husky, "Husky")
          @sled = Sled.new

          @the_dogs = [@dog1, @dog2, @dog3, @dog4, @dog5]
        end

        def inspect
          "A team of sled dogs named #{@dog1.name}, #{@dog2.name}, #{@dog3.name}, #{@dog4.name}, and #{@dog5.name}, with #{@sled.inspect}"
        end

        def name_husky
          # generate random name for husky
          vowels = %w[a e i o u]
          consonants = ('b'..'z').to_a - vowels
          big_vowels = %w[A E I O U]
          big_consonants = ('B'..'Z').to_a - big_vowels

          big_consonants[rand(21)] + vowels[rand(5)] + consonants[rand(21)] + vowels[rand(5)]
        end

        def random_bark
          @the_dogs.sample.speak
        end

        def groom_each
          @the_dogs.each {|dog| p dog.groom}
        end

      end
    </code></pre>

    <p>
      Now consider the calls this allows us to make:
    </p>

    <pre><code>
      p team1 = DogSledTeam.new
      # => A team of sled dogs named Paje, Luro, Samo, Bocu, and Xoge, with a red sled capable of going 50 miles per hour.
      p team1.random_bark
      # => "Luro says Raouf!!"
      p team1.random_bark
      # => "Paje says Raouf!!"
      p team1.random_bark
      # => "Xoge says Raouf!!"
    </code></pre>

    <h3>Composition II: Including Behaviors from a Module</h3>
    <p>
      Another way of marshaling behaviors is by defining a bundle of methods together in a module and then writing <code>include</code> inside a class to include those behaviors in the class.
    </p> 
    <p>
      We actually did this above with <code>Dog</code>. In my file `care_for_module.rb`, which we <code>require</code>d at the top of the other code files, I have the following code:
    </p> 
    <pre><code>
      module CareFor

        def feed
          "#{self.name} has been given food and is eating it!"
        end

        def groom
          "#{self.name} has been groomed and looks like a million bucks!"
        end

      end
    </code></pre>
    <p>
      This is useful because we might want to have methods to groom and feed any number of things, from dogs to children to pet dragons. But (for better or worse) the <code>feed</code> and <code>groom</code> methods only work within classes of objects that have a <code>name</code> method that simply returns the name (which is true of <code>Dog</code> thanks to an <code>attr_accessor</code>).
    </p>
    <p>
      Now we can call <code>DogSledTeam#groom_each</code> and get our sled team looking fine!
    </p>
      
    <pre><code>
      team1.groom_each
      # => "Paje has been groomed and looks like a million bucks!"
      # => "Luro has been groomed and looks like a million bucks!"
      # => "Samo has been groomed and looks like a million bucks!"
      # => "Bocu has been groomed and looks like a million bucks!"
      # => "Xoge has been groomed and looks like a million bucks!"
    </code></pre>

  </section>
</main>

<a id="h5footer" href="../blog/allposts.html"><h4>Back to All Technication Posts</h4></a>
<script src="../js/replacetitle.js"></script>