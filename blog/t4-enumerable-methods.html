<!DOCTYPE html>
<head>
  <!-- Insert page title & ensure it matches post title -->
  <title>The <code>#group_by</code> and <code>#cycle</code> methods</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet-keyboard.css">

  <link href='http://fonts.googleapis.com/css?family=Open+Sans|Roboto' rel='stylesheet' type='text/css'>
</head>

<header>
  <a href="../index.html">
    <figure>
      <img id="jq-key" class="top-keys" src="../images/keys/JQ.png">
      <figcaption>Home</figcaption>
    </figure>
  </a>
  <a href="allposts.html">
    <figure>
      <img id="b-key" class="top-keys" src="../images/keys/B.png">
      <figcaption>All Posts</figcaption>
    </figure>
  </a>
</header>

<main>
  <!-- Insert title below -->
  <h1>The <code>#group_by</code> and <code>#cycle</code> methods</h1>
  <!-- Subtitle, if you want it -->
  <!-- <h3>Subtitle</h3> -->
  <!-- Date -->
  <h4>2015.5.20</h4>

  <section>
    <!-- paragraphs -->
    <p><em>Warning: what follows is a beginner's understanding of Ruby concepts, and while every effort is made to ensure their accuracy, total accuracy is no guarantee.</em></p>
    <p><code>Enumerable</code> in Ruby is an example of a mixin or module. Essentially, modules are like classes in that they are bundles of of methods and constants, but they're unlike classes in that they have no instances. Instead, modules are typically "mixed in" to classes to add functionality to them. <code>Enumerable</code> is mixed in to all of Ruby's classes that represent collections, such as <code>Hash</code> and <code>Array</code> and <code>Range</code>.</p>

    <p>Enough with the theory for now. The point of today's post is to explain the uses of a couple of enumerable methods. Enumerable methods all basically say, "hey, let's get the elements out of a collection, one at a time . . . and then do . . . (something)". Beginner Rubyists are familiar with the <code>#each</code> method. It's perhaps the most basic enumerable method since it simply iterates over the collection and lets any other activity be specified inside a block to come after it. <code>#map</code> is another easy one: it simply iterates over a collection and creates a new collection based on it (given an operation specified in a block to come after it). (Enumerable methods given without a block typically yield a unique <em>enumerator</em>--a useful concept best discussed at a later time.</p>
    
    <p><code>#group_by</code> runs through a collection; asks of each item in that collection, 'What do you return if run through this block?'; and then returns a hash whose keys are those return values and whose values are the collection items that returned those return values. I like <a href="http://ruby-doc.org/core-2.2.2/Enumerable.html#method-i-group_by">this example</a> from the official Ruby docs, using <code>#group_by</code> on a range:</p>

    <pre><code>(1..6).group_by { |i| i%3 } #=&gt; {0=&gt;[3, 6], 1=&gt;[1, 4], 2=&gt;[2, 5]}</code></pre>

    <p>Here's another example:</p>
    <pre><code>fruits = ["apple", "banana", "cherry", "dragonfruit", "elderberry"]
vowels = ["a", "e", "i", "o", "u"]
fruits.group_by { |x| vowels.include?(x[0]) }
# =&gt; {true=&gt;["apple", "elderberry"], false=&gt;["banana", "cherry", "dragonfruit"]}</code></pre>
    
    <p><code>#cycle</code> takes an <code>Integer</code> as a parameter and simply runs through the collection, executing a code block that number of times on the collection. For example:</p>
    <pre><code>fruits.cycle(2) { |x| puts "I WANT AN #{x}" if vowels.include?(x[0]) }
# =&gt;
# I WANT AN apple
# I WANT AN elderberry
# I WANT AN apple
# I WANT AN elderberry</code></pre>
  </section>
</main>

<a id="h4footer" href="../blog/allposts.html"><h4>Back to All Technication Posts</h4></a>

<!-- js to replace post title text with page title text. -->
<script src="../js/replacetitle.js"></script>